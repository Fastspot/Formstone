{"options":[],"events":[],"methods":[{"name":"NoConflict","description":"Resolves plugin namespace conflicts","examples":["Formstone.NoConflict();"]},{"name":"Plugin","description":"Builds a plugin and registers it with jQuery.","params":[{"name":"namespace","type":"string","description":"Plugin namespace"},{"name":"settings","type":"object","description":"Plugin settings"}],"return":{"type":"object","description":"Plugin properties. Includes `defaults`, `classes`, `events`, `functions`, `methods` and `utilities` keys"},"examples":["Formstone.Plugin(\"namespace\", { ... });"]},{"name":"Ready","description":"Replacement for jQuery ready","params":[{"name":"e","type":"object","description":"Event data"}]}],"name":"Core","description":"Formstone Library core. Required for all plugins.","use":"### Formstone Object\r\n\r\nThe Formstone core is a dependency of all JavaScript based components and will contain a few global values, as well as a simple plugin factory. The global Formstone object has access to the following keys:\r\n\r\n| Key | Type | Description |\r\n| --- | --- | --- |\r\n| `$window` | `object` | Reference to jQuery wrapped window |\r\n| `window` | `object` | Reference to original window |\r\n| `$document` | `object` | Reference to jQuery wrapped document |\r\n| `document` | `object` | Reference to original document |\r\n| `$body` | `object` | Reference to jQuery wrapped body tag |\r\n| `Plugins` | `object` | Contains all registered plugins |\r\n| `Version` | `string` | Current version number |\r\n| `support.file` | `boolean` | File API support |\r\n| `support.history` | `boolean` | History API support, including push and pop state |\r\n| `support.matchMedia` | `boolean` | Match Media API support |\r\n| `support.nativeMatchMedia` | `boolean` | Native Match Media API support (no polyfill, requires feature test classing) |\r\n| `support.raf` | `boolean` | Request Animation Frame API support |\r\n| `support.touch` | `boolean` | Touch event support |\r\n| `support.transition` | `boolean` | CSS3 Transition support |\r\n| `userAgent` | `string` | Raw user string |\r\n| `isChrome` | `boolean` | Browser is Chrome |\r\n| `isFirefox` | `boolean` | Browser is FireFox |\r\n| `isSafari` | `boolean` | Browser is Safari |\r\n| `isMobile` | `boolean` | Browser is Mobile |\r\n| `isFirefoxMobile` | `boolean` | Browser is FireFox Mobile |\r\n| `transform` | `string` | Prefixed transform property |\r\n| `transition` | `string` | Prefixed transition property |\r\n| `windowWidth` | `int` | Current window width |\r\n| `windowHeight` | `int` | Current window height |\r\n| `fallbackWidth` | `int` | Match Media fallback width |\r\n\r\nUser agent sniffing isn't always reliable or considered best practice - it should be used sparingly, if at all.\r\n\r\n### Plugin Factory\r\n\r\nThe `Formstone.Plugin` factory function is used to define a plugin. The factory will use the provided namespace to register the plugin with jQuery. The plugin is then available like any other:\r\n\r\n```javascript\r\n$(\".target\").plugin({\r\n  option: value\r\n});\r\n```\r\n\r\n#### AMD Support\r\n\r\nPlugins should remain compatible with module loaders like [RequireJS](http://requirejs.org/) or [webpack](https://webpack.github.io/):\r\n\r\n```javascript\r\n(function(factory) {\r\n  if (typeof define === \"function\" && define.amd) {\r\n    define([\r\n      \"jquery\",\r\n      \"./core\",\r\n      \"./dependency\",\r\n    ], factory);\r\n  } else {\r\n    factory(jQuery, Formstone);\r\n  }\r\n}(function($, Formstone) {\r\n\r\n  // Plugin\r\n\r\n})\r\n\r\n);\r\n```\r\n\r\n### Plugin Types\r\n\r\nThere are two types of plugins that can be defined: Widget or Utility.\r\n\r\n#### Widget\r\n\r\nWidget plugins are implicitly tied to an element to enhance or change the interface. Examples of Widgets include input enhancements like Checkbox or Dropdown. A simple Widget might look like:\r\n\r\n```javascript\r\n/* global define */\r\n\r\n(function(factory) {\r\n  if (typeof define === \"function\" && define.amd) {\r\n    define([\r\n      \"jquery\",\r\n      \"./core\",\r\n      \"./dependency\",\r\n    ], factory);\r\n  } else {\r\n    factory(jQuery, Formstone);\r\n  }\r\n}(function($, Formstone) {\r\n\r\n  \"use strict\";\r\n\r\n  function setup() {\r\n    // this = document\r\n  }\r\n\r\n  function construct(data) {\r\n    // this = jQuery wrapped target element\r\n    // data = instance data\r\n  }\r\n\r\n  function destruct(data) {\r\n    // this = jQuery wrapped target element\r\n    // data = instance data\r\n  }\r\n\r\n  function reset(data) {\r\n    // this = jQuery wrapped target element\r\n    // data = instance data\r\n  }\r\n\r\n  // Register Plugin\r\n\r\n  var Plugin = Formstone.Plugin(\"namespace\", {\r\n      widget: true,\r\n      defaults: {\r\n        option:    value\r\n      },\r\n      classes: [\r\n        \"visible\"\r\n      ],\r\n      methods: {\r\n        _construct     : construct,\r\n        _postConstruct : construct,\r\n        _destruct      : destruct,\r\n        _resize        : resize,\r\n        _raf           : raf,\r\n\r\n        reset          : reset\r\n      },\r\n      utilities: {\r\n        close:         close\r\n      }\r\n    }),\r\n\r\n    // Localize References\r\n\r\n    Classes      = Plugin.classes,\r\n    Events       = Plugin.events,\r\n    Functions    = Plugin.functions;\r\n\r\n  Formstone.Ready(setup);\r\n\r\n})\r\n\r\n);\r\n```\r\n\r\nAs in the example above, Widgets can override the following internal methods by pointing a key to the corresponding local function:\r\n\r\n| Method | Description |\r\n| --- | --- |\r\n| `_construct` | Run at initialization of each instance, scoped to specific instance |\r\n| `_postConstruct` | Run after initialization of current instance set, scoped to specific instance |\r\n| `_destruct` | Run at destruction of each instance, scoped to specific instance |\r\n| `_resize` | Run on window resize, scoped to window |\r\n| `_raf` | Run on request animation frame, scoped to window |\r\n\r\nWhen an instance is created or destroyed, the factory will automatically add or remove the instance's localized plugin data. This data is available as the first argument in any public method call, or by using the namespace to query for the data:\r\n\r\n```javascript\r\nthis.data(\"namespace\");\r\n```\r\n\r\nCustom public methods can also be defined, provided their keys are not prefixed with an underscore (`_`). The underscore signifies a core method and should be avoided when defining public methods. The factory will scope any public method call to the target instance, as well as provide it's plugin data as the first argument followed by any additional arguments:\r\n\r\n```javascript\r\n$(\".target\").namespace(\"reset\", 500);\r\n```\r\n\r\nA Widget can also operate as a singleton, like Lightbox or Tooltip. In this case, events are bound to the instance's target element, while DOM manipulations are tied to a single internal instance. This helps prevent unwanted duplication when the interface pattern calls for a single instance.\r\n\r\n#### Utility\r\n\r\nUtility plugins may interact with DOM nodes but are not necessarily tied to any specific elements. An example of a Utility is the media query event abstraction provided by Media Query. A simple Utility plugin might look like:\r\n\r\n```javascript\r\n/* global define */\r\n\r\n(function(factory) {\r\n  if (typeof define === \"function\" && define.amd) {\r\n    define([\r\n      \"jquery\",\r\n      \"./core\"\r\n    ], factory);\r\n  } else {\r\n    factory(jQuery, Formstone);\r\n  }\r\n}(function($, Formstone) {\r\n\r\n  \"use strict\";\r\n\r\n  function delegate() {\r\n    // Manually handle public methods\r\n  }\r\n\r\n  // Register Plugin\r\n\r\n  var Plugin = Formstone.Plugin(\"namespace\", {\r\n      utilties: {\r\n        _delegate:     delegate\r\n      }\r\n    }),\r\n\r\n    // Internal Defaults\r\n\r\n    Defaults = {\r\n      option    : value\r\n    },\r\n\r\n    // Localize References\r\n\r\n    Document = Formstone.$document[0];\r\n\r\n})\r\n\r\n);\r\n```\r\n\r\nA utility can override the default method delegation by pointing the `_delegate` key to a custom function. The delegate function will need to manually handle any arguments passed. Otherwise, Utilities will use the same public method delegation system as Widgets.\r\n\r\n```javascript\r\n$.namespace(\"reset\", 500);\r\n```\r\n\r\n### Plugin Object\r\n\r\nDefining a plugin using the factory will return an object containing the follow keys:\r\n\r\n| Key | Type | Description |\r\n| --- | --- | --- |\r\n| `namespace` | `string` | plugin namespace |\r\n| `initialized` | `boolean` | initialized state |\r\n| `defaults` | `object` | default options extended with initialization and local options |\r\n| `functions` | `object` | private utility functions |\r\n| `methods` | `object` | public methods |\r\n| `utilities` | `object` | public utility methods |\r\n| `classes` | `object` | namespaced classes strings |\r\n| `events` | `object` | namespaced event strings |\r\n\r\nThese values can then be localized in the scope of the plugin for optimal minimization:\r\n\r\n```javascript\r\nvar Plugin = Formstone.Plugin(“namespace”, {\r\n    ...\r\n  }),\r\n  Defaults     = Plugin.defaults,\r\n  Functions    = Plugin.functions,\r\n  Methods      = Plugin.methods,\r\n  Utilities    = Plugin.utilities,\r\n  Classes      = Plugin.classes,\r\n  Events       = Plugin.events;\r\n```\r\n\r\nThis may seem strangely redundant at first, however multi-dimensional objects do not minimize efficiently. This is also one reason standard prototypal inheritance is not used when building a plugin, however this is not to say a specific plugin could not contain locally scoped prototypes. Plugin design is always up to the developer, the factory simply provides a consistent, DRY approach to the basic plugin pattern.\r\n\r\n#### Classes\r\n\r\nThe `classes` object returned when defining a plugin will contain properly namespaced strings of both default and custom classes. Custom classes will become object keys, while the namespaced class will become the value:\r\n\r\n```javascript\r\nvar Plugin = Formstone.Plugin(“namespace”, {\r\n  ...\r\n  classes: [\r\n    \"visible\",\r\n    \"content\"\r\n  ],\r\n  ...\r\n});\r\n```\r\n\r\n```javascript\r\nvar $element = $(Classes.content);\r\n```\r\n\r\n| Key | Type | Value |\r\n| --- | --- | --- |\r\n| `base` | Default | `.namespace` |\r\n| `element` | Default | `.namespace-element` |\r\n| `visible` | Custom | `.namespace-visible` |\r\n| `content` | Custom | `.namespace-content` |\r\n\r\nThe `classes.raw` key will contain just the namespaced class without the leading '.', useful for building html:\r\n\r\n```javascript\r\nhtml += '<div class=\"' + Classes.raw.content + '\">';\r\n```\r\n\r\n#### Events\r\n\r\nThe `events` object returned when defining a plugin will contain properly namespaced strings of both default and custom events. Custom events will become object keys, while the namespaced event will become the value:\r\n\r\n```javascript\r\nvar Plugin = Formstone.Plugin(“namespace”, {\r\n  ...\r\n  events: [\r\n    \"enable\",\r\n    \"disable\"\r\n  ],\r\n  ...\r\n});\r\n```\r\n\r\n```javascript\r\ndata.$el.on(Events.click, onClick);\r\n```\r\n\r\n| Key | Type | Value |\r\n| --- | --- | --- |\r\n| `namespace` | Default | `.namespace` |\r\n| `beforeUnload` | Default | `beforeunload.namespace` |\r\n| `blur` | Default | `blur.namespace` |\r\n| `change` | Default | `change.namespace` |\r\n| `click` | Default | `click.namespace` |\r\n| `clickTouchStart` | Default | `click.namespace touchstart.namespace` |\r\n| `dblClick` | Default | `dblClick.namespace` |\r\n| `drag` | Default | `drag.namespace` |\r\n| `dragEnd` | Default | `dragend.namespace` |\r\n| `dragEnter` | Default | `dragenter.namespace` |\r\n| `dragLeave` | Default | `dragleave.namespace` |\r\n| `dragOver` | Default | `dragover.namespace` |\r\n| `dragStart` | Default | `dragstart.namespace` |\r\n| `drop` | Default | `drop.namespace` |\r\n| `error` | Default | `error.namespace` |\r\n| `focus` | Default | `focus.namespace` |\r\n| `focusIn` | Default | `focusin.namespace` |\r\n| `focusOut` | Default | `focusout.namespace` |\r\n| `input` | Default | `input.namespace` |\r\n| `keyDown` | Default | `keydown.namespace` |\r\n| `keyPress` | Default | `keypress.namespace` |\r\n| `keyUp` | Default | `keyup.namespace` |\r\n| `load` | Default | `load.namespace` |\r\n| `mouseDown` | Default | `mousedown.namespace` |\r\n| `mouseEnter` | Default | `mouseenter.namespace` |\r\n| `mouseLeave` | Default | `mouseleave.namespace` |\r\n| `mouseMove` | Default | `mousemove.namespace` |\r\n| `mouseOut` | Default | `mouseout.namespace` |\r\n| `mouseOver` | Default | `mouseover.namespace` |\r\n| `mouseUp` | Default | `mouseup.namespace` |\r\n| `panStart` | Default | `panstart.namespace` |\r\n| `pan` | Default | `pan.namespace` |\r\n| `panEnd` | Default | `panend.namespace` |\r\n| `resize` | Default | `resize.namespace` |\r\n| `scaleStart` | Default | `scalestart.namespace` |\r\n| `scale` | Default | `scale.namespace` |\r\n| `scaleEnd` | Default | `scaleend.namespace` |\r\n| `scroll` | Default | `scroll.namespace` |\r\n| `select` | Default | `select.namespace` |\r\n| `swipe` | Default | `swipe.namespace` |\r\n| `touchCancel` | Default | `touchcancel.namespace` |\r\n| `touchEnd` | Default | `touchend.namespace` |\r\n| `touchLeave` | Default | `touchleave.namespace` |\r\n| `touchMove` | Default | `touchmove.namespace` |\r\n| `touchStart` | Default | `touchstart.namespace` |\r\n| `transitionEnd` | Default | `transitionEnd.namespace` |\r\n\r\n### Document Ready\r\n\r\nChanges introduced to the `ready` event handler in jQuery 3 can cause a flash of unstyled content before widget plugins have completely initialized. The `Formstone.Ready` handler utilizes the native 'DOMContentLoaded' event to avoid the flash and can be safely used a jQuery `ready` replacement:\r\n\r\n```javascript\r\nFormstone.Ready(function() {\r\n  ...\r\n});\r\n```\r\n\r\n### No Conflict\r\n\r\nOne benefit of Formstone is the module nature of the components, allowing developers to include only what's required. Certain edge cases may require overlapping namespaces between two or more libraries. To avoid (some) namespace collisions with other libraries, such as Bootstrap or Lightbox, developers can call the `Formstone.NoConflict()` method to restore all jQuery plugin namespaces to their 'original' functions. Other libraries should be included before Formstone components, however Formstone will remember this flag and avoid registering un-namespaced plugins included after the initial call. Note: This does not effect data attributes or events, only the jQuery plugin namespace.\r\n\r\n```javascript\r\nFormstone.NoConflict();\r\n```\r\n","demo":"[No Demo]","document":"# Core\n\nFormstone Library core. Required for all plugins.\n\n<!-- HEADER END -->\n\n<!-- NAV START -->\n\n* [Use](#use)\n* [Methods](#methods)\n\n<!-- NAV END -->\n\n<!-- DEMO BUTTON -->\n\n<a name=\"use\"></a>\n\n## Using Core\n\n### Formstone Object\r\n\r\nThe Formstone core is a dependency of all JavaScript based components and will contain a few global values, as well as a simple plugin factory. The global Formstone object has access to the following keys:\r\n\r\n| Key | Type | Description |\r\n| --- | --- | --- |\r\n| `$window` | `object` | Reference to jQuery wrapped window |\r\n| `window` | `object` | Reference to original window |\r\n| `$document` | `object` | Reference to jQuery wrapped document |\r\n| `document` | `object` | Reference to original document |\r\n| `$body` | `object` | Reference to jQuery wrapped body tag |\r\n| `Plugins` | `object` | Contains all registered plugins |\r\n| `Version` | `string` | Current version number |\r\n| `support.file` | `boolean` | File API support |\r\n| `support.history` | `boolean` | History API support, including push and pop state |\r\n| `support.matchMedia` | `boolean` | Match Media API support |\r\n| `support.nativeMatchMedia` | `boolean` | Native Match Media API support (no polyfill, requires feature test classing) |\r\n| `support.raf` | `boolean` | Request Animation Frame API support |\r\n| `support.touch` | `boolean` | Touch event support |\r\n| `support.transition` | `boolean` | CSS3 Transition support |\r\n| `userAgent` | `string` | Raw user string |\r\n| `isChrome` | `boolean` | Browser is Chrome |\r\n| `isFirefox` | `boolean` | Browser is FireFox |\r\n| `isSafari` | `boolean` | Browser is Safari |\r\n| `isMobile` | `boolean` | Browser is Mobile |\r\n| `isFirefoxMobile` | `boolean` | Browser is FireFox Mobile |\r\n| `transform` | `string` | Prefixed transform property |\r\n| `transition` | `string` | Prefixed transition property |\r\n| `windowWidth` | `int` | Current window width |\r\n| `windowHeight` | `int` | Current window height |\r\n| `fallbackWidth` | `int` | Match Media fallback width |\r\n\r\nUser agent sniffing isn't always reliable or considered best practice - it should be used sparingly, if at all.\r\n\r\n### Plugin Factory\r\n\r\nThe `Formstone.Plugin` factory function is used to define a plugin. The factory will use the provided namespace to register the plugin with jQuery. The plugin is then available like any other:\r\n\r\n```javascript\r\n$(\".target\").plugin({\r\n  option: value\r\n});\r\n```\r\n\r\n#### AMD Support\r\n\r\nPlugins should remain compatible with module loaders like [RequireJS](http://requirejs.org/) or [webpack](https://webpack.github.io/):\r\n\r\n```javascript\r\n(function(factory) {\r\n  if (typeof define === \"function\" && define.amd) {\r\n    define([\r\n      \"jquery\",\r\n      \"./core\",\r\n      \"./dependency\",\r\n    ], factory);\r\n  } else {\r\n    factory(jQuery, Formstone);\r\n  }\r\n}(function($, Formstone) {\r\n\r\n  // Plugin\r\n\r\n})\r\n\r\n);\r\n```\r\n\r\n### Plugin Types\r\n\r\nThere are two types of plugins that can be defined: Widget or Utility.\r\n\r\n#### Widget\r\n\r\nWidget plugins are implicitly tied to an element to enhance or change the interface. Examples of Widgets include input enhancements like Checkbox or Dropdown. A simple Widget might look like:\r\n\r\n```javascript\r\n/* global define */\r\n\r\n(function(factory) {\r\n  if (typeof define === \"function\" && define.amd) {\r\n    define([\r\n      \"jquery\",\r\n      \"./core\",\r\n      \"./dependency\",\r\n    ], factory);\r\n  } else {\r\n    factory(jQuery, Formstone);\r\n  }\r\n}(function($, Formstone) {\r\n\r\n  \"use strict\";\r\n\r\n  function setup() {\r\n    // this = document\r\n  }\r\n\r\n  function construct(data) {\r\n    // this = jQuery wrapped target element\r\n    // data = instance data\r\n  }\r\n\r\n  function destruct(data) {\r\n    // this = jQuery wrapped target element\r\n    // data = instance data\r\n  }\r\n\r\n  function reset(data) {\r\n    // this = jQuery wrapped target element\r\n    // data = instance data\r\n  }\r\n\r\n  // Register Plugin\r\n\r\n  var Plugin = Formstone.Plugin(\"namespace\", {\r\n      widget: true,\r\n      defaults: {\r\n        option:    value\r\n      },\r\n      classes: [\r\n        \"visible\"\r\n      ],\r\n      methods: {\r\n        _construct     : construct,\r\n        _postConstruct : construct,\r\n        _destruct      : destruct,\r\n        _resize        : resize,\r\n        _raf           : raf,\r\n\r\n        reset          : reset\r\n      },\r\n      utilities: {\r\n        close:         close\r\n      }\r\n    }),\r\n\r\n    // Localize References\r\n\r\n    Classes      = Plugin.classes,\r\n    Events       = Plugin.events,\r\n    Functions    = Plugin.functions;\r\n\r\n  Formstone.Ready(setup);\r\n\r\n})\r\n\r\n);\r\n```\r\n\r\nAs in the example above, Widgets can override the following internal methods by pointing a key to the corresponding local function:\r\n\r\n| Method | Description |\r\n| --- | --- |\r\n| `_construct` | Run at initialization of each instance, scoped to specific instance |\r\n| `_postConstruct` | Run after initialization of current instance set, scoped to specific instance |\r\n| `_destruct` | Run at destruction of each instance, scoped to specific instance |\r\n| `_resize` | Run on window resize, scoped to window |\r\n| `_raf` | Run on request animation frame, scoped to window |\r\n\r\nWhen an instance is created or destroyed, the factory will automatically add or remove the instance's localized plugin data. This data is available as the first argument in any public method call, or by using the namespace to query for the data:\r\n\r\n```javascript\r\nthis.data(\"namespace\");\r\n```\r\n\r\nCustom public methods can also be defined, provided their keys are not prefixed with an underscore (`_`). The underscore signifies a core method and should be avoided when defining public methods. The factory will scope any public method call to the target instance, as well as provide it's plugin data as the first argument followed by any additional arguments:\r\n\r\n```javascript\r\n$(\".target\").namespace(\"reset\", 500);\r\n```\r\n\r\nA Widget can also operate as a singleton, like Lightbox or Tooltip. In this case, events are bound to the instance's target element, while DOM manipulations are tied to a single internal instance. This helps prevent unwanted duplication when the interface pattern calls for a single instance.\r\n\r\n#### Utility\r\n\r\nUtility plugins may interact with DOM nodes but are not necessarily tied to any specific elements. An example of a Utility is the media query event abstraction provided by Media Query. A simple Utility plugin might look like:\r\n\r\n```javascript\r\n/* global define */\r\n\r\n(function(factory) {\r\n  if (typeof define === \"function\" && define.amd) {\r\n    define([\r\n      \"jquery\",\r\n      \"./core\"\r\n    ], factory);\r\n  } else {\r\n    factory(jQuery, Formstone);\r\n  }\r\n}(function($, Formstone) {\r\n\r\n  \"use strict\";\r\n\r\n  function delegate() {\r\n    // Manually handle public methods\r\n  }\r\n\r\n  // Register Plugin\r\n\r\n  var Plugin = Formstone.Plugin(\"namespace\", {\r\n      utilties: {\r\n        _delegate:     delegate\r\n      }\r\n    }),\r\n\r\n    // Internal Defaults\r\n\r\n    Defaults = {\r\n      option    : value\r\n    },\r\n\r\n    // Localize References\r\n\r\n    Document = Formstone.$document[0];\r\n\r\n})\r\n\r\n);\r\n```\r\n\r\nA utility can override the default method delegation by pointing the `_delegate` key to a custom function. The delegate function will need to manually handle any arguments passed. Otherwise, Utilities will use the same public method delegation system as Widgets.\r\n\r\n```javascript\r\n$.namespace(\"reset\", 500);\r\n```\r\n\r\n### Plugin Object\r\n\r\nDefining a plugin using the factory will return an object containing the follow keys:\r\n\r\n| Key | Type | Description |\r\n| --- | --- | --- |\r\n| `namespace` | `string` | plugin namespace |\r\n| `initialized` | `boolean` | initialized state |\r\n| `defaults` | `object` | default options extended with initialization and local options |\r\n| `functions` | `object` | private utility functions |\r\n| `methods` | `object` | public methods |\r\n| `utilities` | `object` | public utility methods |\r\n| `classes` | `object` | namespaced classes strings |\r\n| `events` | `object` | namespaced event strings |\r\n\r\nThese values can then be localized in the scope of the plugin for optimal minimization:\r\n\r\n```javascript\r\nvar Plugin = Formstone.Plugin(“namespace”, {\r\n    ...\r\n  }),\r\n  Defaults     = Plugin.defaults,\r\n  Functions    = Plugin.functions,\r\n  Methods      = Plugin.methods,\r\n  Utilities    = Plugin.utilities,\r\n  Classes      = Plugin.classes,\r\n  Events       = Plugin.events;\r\n```\r\n\r\nThis may seem strangely redundant at first, however multi-dimensional objects do not minimize efficiently. This is also one reason standard prototypal inheritance is not used when building a plugin, however this is not to say a specific plugin could not contain locally scoped prototypes. Plugin design is always up to the developer, the factory simply provides a consistent, DRY approach to the basic plugin pattern.\r\n\r\n#### Classes\r\n\r\nThe `classes` object returned when defining a plugin will contain properly namespaced strings of both default and custom classes. Custom classes will become object keys, while the namespaced class will become the value:\r\n\r\n```javascript\r\nvar Plugin = Formstone.Plugin(“namespace”, {\r\n  ...\r\n  classes: [\r\n    \"visible\",\r\n    \"content\"\r\n  ],\r\n  ...\r\n});\r\n```\r\n\r\n```javascript\r\nvar $element = $(Classes.content);\r\n```\r\n\r\n| Key | Type | Value |\r\n| --- | --- | --- |\r\n| `base` | Default | `.namespace` |\r\n| `element` | Default | `.namespace-element` |\r\n| `visible` | Custom | `.namespace-visible` |\r\n| `content` | Custom | `.namespace-content` |\r\n\r\nThe `classes.raw` key will contain just the namespaced class without the leading '.', useful for building html:\r\n\r\n```javascript\r\nhtml += '<div class=\"' + Classes.raw.content + '\">';\r\n```\r\n\r\n#### Events\r\n\r\nThe `events` object returned when defining a plugin will contain properly namespaced strings of both default and custom events. Custom events will become object keys, while the namespaced event will become the value:\r\n\r\n```javascript\r\nvar Plugin = Formstone.Plugin(“namespace”, {\r\n  ...\r\n  events: [\r\n    \"enable\",\r\n    \"disable\"\r\n  ],\r\n  ...\r\n});\r\n```\r\n\r\n```javascript\r\ndata.$el.on(Events.click, onClick);\r\n```\r\n\r\n| Key | Type | Value |\r\n| --- | --- | --- |\r\n| `namespace` | Default | `.namespace` |\r\n| `beforeUnload` | Default | `beforeunload.namespace` |\r\n| `blur` | Default | `blur.namespace` |\r\n| `change` | Default | `change.namespace` |\r\n| `click` | Default | `click.namespace` |\r\n| `clickTouchStart` | Default | `click.namespace touchstart.namespace` |\r\n| `dblClick` | Default | `dblClick.namespace` |\r\n| `drag` | Default | `drag.namespace` |\r\n| `dragEnd` | Default | `dragend.namespace` |\r\n| `dragEnter` | Default | `dragenter.namespace` |\r\n| `dragLeave` | Default | `dragleave.namespace` |\r\n| `dragOver` | Default | `dragover.namespace` |\r\n| `dragStart` | Default | `dragstart.namespace` |\r\n| `drop` | Default | `drop.namespace` |\r\n| `error` | Default | `error.namespace` |\r\n| `focus` | Default | `focus.namespace` |\r\n| `focusIn` | Default | `focusin.namespace` |\r\n| `focusOut` | Default | `focusout.namespace` |\r\n| `input` | Default | `input.namespace` |\r\n| `keyDown` | Default | `keydown.namespace` |\r\n| `keyPress` | Default | `keypress.namespace` |\r\n| `keyUp` | Default | `keyup.namespace` |\r\n| `load` | Default | `load.namespace` |\r\n| `mouseDown` | Default | `mousedown.namespace` |\r\n| `mouseEnter` | Default | `mouseenter.namespace` |\r\n| `mouseLeave` | Default | `mouseleave.namespace` |\r\n| `mouseMove` | Default | `mousemove.namespace` |\r\n| `mouseOut` | Default | `mouseout.namespace` |\r\n| `mouseOver` | Default | `mouseover.namespace` |\r\n| `mouseUp` | Default | `mouseup.namespace` |\r\n| `panStart` | Default | `panstart.namespace` |\r\n| `pan` | Default | `pan.namespace` |\r\n| `panEnd` | Default | `panend.namespace` |\r\n| `resize` | Default | `resize.namespace` |\r\n| `scaleStart` | Default | `scalestart.namespace` |\r\n| `scale` | Default | `scale.namespace` |\r\n| `scaleEnd` | Default | `scaleend.namespace` |\r\n| `scroll` | Default | `scroll.namespace` |\r\n| `select` | Default | `select.namespace` |\r\n| `swipe` | Default | `swipe.namespace` |\r\n| `touchCancel` | Default | `touchcancel.namespace` |\r\n| `touchEnd` | Default | `touchend.namespace` |\r\n| `touchLeave` | Default | `touchleave.namespace` |\r\n| `touchMove` | Default | `touchmove.namespace` |\r\n| `touchStart` | Default | `touchstart.namespace` |\r\n| `transitionEnd` | Default | `transitionEnd.namespace` |\r\n\r\n### Document Ready\r\n\r\nChanges introduced to the `ready` event handler in jQuery 3 can cause a flash of unstyled content before widget plugins have completely initialized. The `Formstone.Ready` handler utilizes the native 'DOMContentLoaded' event to avoid the flash and can be safely used a jQuery `ready` replacement:\r\n\r\n```javascript\r\nFormstone.Ready(function() {\r\n  ...\r\n});\r\n```\r\n\r\n### No Conflict\r\n\r\nOne benefit of Formstone is the module nature of the components, allowing developers to include only what's required. Certain edge cases may require overlapping namespaces between two or more libraries. To avoid (some) namespace collisions with other libraries, such as Bootstrap or Lightbox, developers can call the `Formstone.NoConflict()` method to restore all jQuery plugin namespaces to their 'original' functions. Other libraries should be included before Formstone components, however Formstone will remember this flag and avoid registering un-namespaced plugins included after the initial call. Note: This does not effect data attributes or events, only the jQuery plugin namespace.\r\n\r\n```javascript\r\nFormstone.NoConflict();\r\n```\r\n\n\n<hr>\n<a name=\"methods\"></a>\n\n## Methods\n\n### NoConflict\n\nResolves plugin namespace conflicts\n\n```javascript\nFormstone.NoConflict();\n```\n\n### Plugin\n\nBuilds a plugin and registers it with jQuery.\n\n```javascript\nFormstone.Plugin(\"namespace\", { ... });\n```\n\n#### Parameters\n\n| Name | Type | Default | Description |\n| --- | --- | --- | --- |\n| `namespace` | `string` | &nbsp; | Plugin namespace |\n| `settings` | `object` | &nbsp; | Plugin settings |\n\n### Ready\n\nReplacement for jQuery ready\n\n\n#### Parameters\n\n| Name | Type | Default | Description |\n| --- | --- | --- | --- |\n| `e` | `object` | &nbsp; | Event data |\n\n"}